using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using RiseOn.AutoInject.Extensions;

namespace RiseOn.AutoInject
{
    internal static class SourceGeneratorHelper
    {
        private const string Header = "//------------------------------------------------------------------------------\n" +
                                      "// <auto-generated>\n" +
                                      "//     This code was generated by the RiseOn.AutoInject source generator\n" +
                                      "//\n" +
                                      "//     Changes to this file may cause incorrect behavior and will be lost if\n" +
                                      "//     the code is regenerated.\n" +
                                      "// </auto-generated>\n" +
                                      "//------------------------------------------------------------------------------\n";

        internal static ServiceInfo GetServiceInfo(GeneratorAttributeSyntaxContext context)
        {
            var attribute = context.Attributes[0];
            var symbol = (INamedTypeSymbol)context.TargetSymbol;

            var arguments = attribute.NamedArguments
                .ToDictionary(arg => arg.Key, arg => arg.Value.Value);

            var lifetimeArg = (int?)attribute.ConstructorArguments[0].Value;
            var injectAlone = (bool?)attribute.ConstructorArguments[1].Value ?? false;

            var serviceLifetime = lifetimeArg switch
            {
                0 => "Singleton",
                1 => "Scoped",
                2 => "Transient",
                _ => throw new InvalidOperationException("Invalid service lifetime value!")
            };

            return new ServiceInfo
            {
                ServiceLifetime = serviceLifetime,
                Namespace = arguments.GetValueOrDefault("ServicesNameSpace")?.ToString(),
                ServiceName = symbol.ToDisplayString(),
                CollectionName = arguments.GetValueOrDefault("CollectionName")?.ToString()
                    ?? (symbol.ContainingNamespace is { IsGlobalNamespace: false }
                        ? symbol.ContainingNamespace.ToDisplayString().Replace(".", "") + "Services"
                        : "AutoInjectedServices"),
                ImplementationName = GetImplementationName(
                    symbol,
                    arguments.GetValueOrDefault("ImplementationOf")?.ToString(),
                    injectAlone
                ),
                Key = arguments.GetValueOrDefault("Key")
            };
        }

        private static string? GetImplementationName(INamedTypeSymbol symbol,
            string? implementationOf, bool injectAlone)
        {
             if (injectAlone)
                return null;

            if (!string.IsNullOrEmpty(implementationOf))
                return implementationOf;

            return symbol.Interfaces.FirstOrDefault()?.ToDisplayString() ??
                   (symbol.BaseType?.SpecialType != SpecialType.System_Object ? symbol.BaseType?.ToDisplayString() : null);
        }

        internal static string GenerateSourceClass(IEnumerable<ServiceInfo> serviceInfos)
        {
            var services = serviceInfos.ToList();
            if (!services.Any())
                throw new ArgumentException("ServiceInfos cannot be empty", nameof(serviceInfos));

            var first = services.First();

            var sb = new StringBuilder(Header)
                .AppendLine("using Microsoft.Extensions.DependencyInjection;")
                .AppendLine();

            if (!string.IsNullOrEmpty(first.Namespace))
                sb.AppendLine($"namespace {first.Namespace};").AppendLine();

            sb.AppendLine($"public static class {first.CollectionName}CollectionExtensions")
                .AppendLine("{")
                .AppendLine($"    public static IServiceCollection Use{first.CollectionName}(this IServiceCollection services)")
                .AppendLine("    {");

            foreach (var service in services)
            {
                sb.AppendLine($"        {GenerateServiceRegistration(service)}");
            }

            sb.AppendLine("        return services;")
                .AppendLine("    }")
                .AppendLine("}");

            return sb.ToString();
        }

        private static string GenerateServiceRegistration(ServiceInfo service)
        {
            var method = service.Key != null ? "AddKeyed" : "Add";
            var types = service.ImplementationName is null
                ? $"<{service.ServiceName}>"
                : $"<{service.ImplementationName}, {service.ServiceName}>";
            var key = service.Key != null ? $", \"{service.Key}\"" : string.Empty;

            return $"services.{method}{service.ServiceLifetime}{types}({key.TrimStart(',')});";
        }
    }
}