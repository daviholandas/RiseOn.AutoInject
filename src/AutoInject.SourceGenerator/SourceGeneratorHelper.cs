using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace RiseOn.AutoInject
{
    public static class SourceGeneratorHelper
    {
        private const string Header = @"
          //------------------------------------------------------------------------------
          // <auto-generated>
          //     This code was generated by the RiseOn.AutoInject source generator
          //
          //     Changes to this file may cause incorrect behavior and will be lost if
          //     the code is regenerated.
          // </auto-generated>
          //------------------------------------------------------------------------------
        ";


        public static ServiceInfo GetServiceInfo(GeneratorAttributeSyntaxContext context)
        {
            var symbol = (INamedTypeSymbol)context.TargetSymbol;
            var name = symbol.ToDisplayString();

            var interfaceName = symbol.Interfaces.Length > 0 ? symbol.Interfaces[0].ToDisplayString() : null;
            var baseType = symbol.BaseType;
            var baseName = baseType != null &&
                           baseType.SpecialType != SpecialType.System_Object ?
                baseType.ToDisplayString() :
                null;

            var collectionDefault = symbol.ContainingNamespace.ToDisplayString().Replace(".", "");

            var serviceLifetime = context.Attributes[0].ConstructorArguments[0].Value?.ToString() switch
            {
                "0" => "Singleton",
                "1" => "Scoped",
                "2" => "Transient",
                _ => throw new InvalidOperationException($"Invalid service lifetime value!")
            };

            var argumentsNamed = context.Attributes[0].NamedArguments;

            var ns = argumentsNamed
                .FirstOrDefault(x => x.Key == "ServicesNameSpace").Value.Value?.ToString();
            var collectionName = argumentsNamed
                .FirstOrDefault(x => x.Key == "CollectionName").Value.Value?.ToString();
            var implementationOf = argumentsNamed
                .FirstOrDefault(x => x.Key == "ImplementationOf").Value.Value?.ToString();
            var serviceKey = argumentsNamed
                .FirstOrDefault(x => x.Key == "Key").Value.Value;

            return new()
            {
                ServiceLifetime = serviceLifetime,
                Namespace = ns,
                ServiceName = name,
                CollectionName = collectionName ?? collectionDefault + "Services" ,
                ImplementationName = string.IsNullOrEmpty(implementationOf) ? interfaceName ?? baseName : implementationOf,
                Key = serviceKey
            };
        }

        public static string GenerateSourceClass(IEnumerable<ServiceInfo> serviceInfos)
        {
            var sb = new StringBuilder();
            var service = serviceInfos.First();

            sb.AppendLine(Header);

            sb.AppendLine("using Microsoft.Extensions.DependencyInjection;\n");

            if(!string.IsNullOrEmpty(service.Namespace))
                sb.AppendLine($"namespace {service.Namespace};\n");

            sb.AppendLine($"public static class {service.CollectionName}CollectionExtensions");
            sb.AppendLine("{");
            sb.AppendLine($"    public static IServiceCollection Use{service.CollectionName}(this IServiceCollection services)");
            sb.AppendLine("    {");

            foreach (var serviceInfo in serviceInfos)
            {
                var method = serviceInfo.Key != null ? "AddKeyed" : "Add";
                var types = serviceInfo.ImplementationName is null 
                    ? $"<{serviceInfo.ServiceName}>"
                    : $"<{serviceInfo.ImplementationName}, {serviceInfo.ServiceName}>";
                var key = serviceInfo.Key != null ? $@"""{serviceInfo.Key}""" : string.Empty;
                
                sb.AppendLine($"        services.{method}{serviceInfo.ServiceLifetime}{types}({key});");
            }
            sb.AppendLine("        return services;");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }
    }
}