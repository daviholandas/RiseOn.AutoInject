using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using RiseOn.AutoInject.Extensions;

namespace RiseOn.AutoInject
{
    public static class SourceGeneratorHelper
    {
        private const string Header = "//------------------------------------------------------------------------------\n" +
                                      "// <auto-generated>\n" +
                                      "//     This code was generated by the RiseOn.AutoInject source generator\n" +
                                      "//\n" +
                                      "//     Changes to this file may cause incorrect behavior and will be lost if\n" +
                                      "//     the code is regenerated.\n" +
                                      "// </auto-generated>\n" +
                                      "//------------------------------------------------------------------------------\n";

        public static ServiceInfo GetServiceInfo(GeneratorAttributeSyntaxContext context)
        {
            var symbol = (INamedTypeSymbol)context.TargetSymbol;

            var arguments = context.Attributes[0].NamedArguments
                .ToDictionary(arg => arg.Key, arg => arg.Value.Value);

            var interfaceName = symbol.Interfaces.FirstOrDefault()?.ToDisplayString();
            var baseType = symbol.BaseType;
            var baseName = baseType != null && baseType.SpecialType != SpecialType.System_Object
                ? baseType.ToDisplayString()
                : null;

            return new ServiceInfo
            {
                ServiceLifetime = (int?)context.Attributes[0].ConstructorArguments[0].Value switch
                {
                    0 => "Singleton",
                    1 => "Scoped",
                    2 => "Transient",
                    _ => throw new InvalidOperationException("Invalid service lifetime value!")
                },
                Namespace = arguments.GetValueOrDefault("ServicesNameSpace")?.ToString(),
                ServiceName = symbol.ToDisplayString(),
                CollectionName = arguments.GetValueOrDefault("CollectionName")?.ToString() ??
                                 (symbol.ContainingNamespace is { IsGlobalNamespace: false }  ?
                                     symbol.ContainingNamespace.ToDisplayString().Replace(".", "") + "Services" :
                                     "AutoInjectedServices"),
                ImplementationName = GetImplementationName(symbol, arguments.GetValueOrDefault("ImplementationOf")?.ToString()),
                Key = arguments.GetValueOrDefault("Key")
            };
        }

        private static string? GetImplementationName(INamedTypeSymbol symbol, string? implementationOf)
        {
            // TODO check if implementation type is a valid, not a system type and when not have a interface or base type but a system type
            if (!string.IsNullOrEmpty(implementationOf))
                return implementationOf;

            return symbol.Interfaces.FirstOrDefault()?.ToDisplayString() ??
                   (symbol.BaseType?.SpecialType != SpecialType.System_Object ? symbol.BaseType?.ToDisplayString() : null);
        }

        public static string GenerateSourceClass(IEnumerable<ServiceInfo> serviceInfos)
        {
            var services = serviceInfos.ToList();
            if (!services.Any())
                throw new ArgumentException("ServiceInfos cannot be empty", nameof(serviceInfos));

            var first = services.First();

            var sb = new StringBuilder(Header)
                .AppendLine("using Microsoft.Extensions.DependencyInjection;")
                .AppendLine();

            if (!string.IsNullOrEmpty(first.Namespace))
                sb.AppendLine($"namespace {first.Namespace};").AppendLine();

            sb.AppendLine($"public static class {first.CollectionName}CollectionExtensions")
                .AppendLine("{")
                .AppendLine($"    public static IServiceCollection Use{first.CollectionName}(this IServiceCollection services)")
                .AppendLine("    {");

            foreach (var service in services)
            {
                sb.AppendLine($"        {GenerateServiceRegistration(service)}");
            }

            sb.AppendLine("        return services;")
                .AppendLine("    }")
                .AppendLine("}");

            return sb.ToString();
        }

        private static string GenerateServiceRegistration(ServiceInfo service)
        {
            var method = service.Key != null ? "AddKeyed" : "Add";
            var types = service.ImplementationName is null
                ? $"<{service.ServiceName}>"
                : $"<{service.ImplementationName}, {service.ServiceName}>";
            var key = service.Key != null ? $", \"{service.Key}\"" : string.Empty;

            return $"services.{method}{service.ServiceLifetime}{types}({key.TrimStart(',')});";
        }
    }
}